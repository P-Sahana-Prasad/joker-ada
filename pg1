import time
import random
import math

# Linear Complexity (O(n)): A function that iterates through a list once.
def linear_function(n):
    total = 0
    for i in range(n):
        total += i
    return total

# Quadratic Complexity (O(n^2)): A function with two nested loops.
def quadratic_function(n):
    total = 0
    for i in range(n):
        for j in range(n):
            total += i * j
    return total

# Logarithmic Complexity (O(log n)): A function that divides the problem size in half each time.
def logarithmic_function(n):
    count = 0
    while n > 1:
        n //= 2
        count += 1
    return count

# Function to measure the time taken by each algorithm
def time_function(func, n):
    start_time = time.time()
    func(n)
    end_time = time.time()
    return end_time - start_time

# Testing the functions with different input sizes and analyzing the performance
def analyze_performance():
    sizes = [10, 100, 1000, 5000, 10000]
    print(f"{'Size':<10}{'Linear (O(n))':<20}{'Quadratic (O(n^2))':<25}{'Logarithmic (O(log n))':<30}")
    
    for size in sizes:
        linear_time = time_function(linear_function, size)
        quadratic_time = time_function(quadratic_function, size)
        logarithmic_time = time_function(logarithmic_function, size)
        
        print(f"{size:<10}{linear_time:<20}{quadratic_time:<25}{logarithmic_time:<30}")
Output:
# Run the performance analysis
analyze_performance()
Size      Linear (O(n))    Quadratic (O(n^2))    Logarithmic (O(log n))
10        1.2e-06          1.7e-05               3.0e-07               
100       1.5e-06          0.0023                1.3e-06               
1000      2.0e-06          0.0849                6.5e-06               
5000      2.5e-06          6.35                  2.3e-05               
10000     3.0e-06          24.7                  6.5e-05
